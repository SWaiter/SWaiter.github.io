---
layout: post
title: hive仓库创建json格式表
categories: swaiter
description: hive仓库创建json格式表
keywords: hive json
---


在现有的数据资产管理系统中，系统支持text、orc等格式的表，其中text格式的表列可以由多种分割符进行分割，由于需要，仓库中需要存储json相关的数据，因此，系统需要支持json格式表创建，遇到的问题总结如下：


### 实现

首先就是引入JsonSerDe包的问题。
首先，系统自带的有相关的jar包。  
另外，也有第三方开源的jar包。[第三方](https://github.com/rcongiu/Hive-JSON-Serde)
第三方做了相关的优化，下面有有介绍。

###hive官方文档
hive官方文档有相关[json serde](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-JSON)介绍
```bash
Stored as plain text file in JSON format.

The JsonSerDe for JSON files is available in Hive 0.12 and later.

In some distributions, a reference to hive-hcatalog-core.jar is required.
ADD JAR /usr/lib/hive-hcatalog/lib/hive-hcatalog-core.jar;

CREATE TABLE my_table(a string, b bigint, ...)
ROW FORMAT SERDE 'org.apache.hive.hcatalog.data.JsonSerDe'
STORED AS TEXTFILE;

The JsonSerDe was moved to Hive from HCatalog and before it was in hive-contrib project. It was added to the Hive distribution by HIVE-4895.
An Amazon SerDe is available at s3://elasticmapreduce/samples/hive-ads/libs/jsonserde.jar for releases prior to 0.12.0.

The JsonSerDe for JSON files is available in Hive 0.12 and later.
Starting in Hive 3.0.0, JsonSerDe is added to Hive Serde as "org.apache.hadoop.hive.serde2.JsonSerDe" (HIVE-19211).
CREATE TABLE my_table(a string, b bigint, ...)
ROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.JsonSerDe'
STORED AS TEXTFILE;

Or STORED AS JSONFILE is supported starting in Hive 4.0.0 (HIVE-19899), so you can create table as follows:

CREATE TABLE my_table(a string, b bigint, ...) STORED AS JSONFILE;
```


### 创建
在hive客户端执行以下
```sql
create EXTERNAL table employees_json1 (firstName string, lastname string,        employeenumber int )
 ROW FORMAT SERDE 'org.apache.hive.hcatalog.data.JsonSerDe'
;
```
可能会遇到以下问题：
1、创建时Error:"java.lang.ClassNotFoundException Class org.apache.hive.hcatalog.data.JsonSerDe not found" 
原因是缺少相关的包。
导入json数据到 test_data.json文件中
```bash
{ "firstName" : "asMike", "lastName" : "asdfpesky", "employeeNumber" : 40192 }
{ "firstName" : "asMike", "lastName" : "asdfesky", "employeeNumber" : 123192 }
{ "firstName" : "Mikasde", "lastName" : "Chepesky", "employeeNumber" : 192 }
```
然后上传数据到hdfs上
```bash
hadoop fs -put -f test_data.json /user/datacenter/test_data.json
```
插入数据到表中
```bash
load data inpath '/user/datacenter/test_data.json' overwrite into table employees_json1;
```
查询数据
```sql
select * from employees_json1
```

直接调用rpc方法，获取productService实现对象，这个对象通过动态代理的方式获取，如果想了解动态代理和反射知识点，可以参考我的另外两个开源的源码地址

[我的git地址 https://github.com/SWaiter/proxy.git](https://github.com/SWaiter/proxy.git)
[我的git地址 https://github.com/SWaiter/reflect.git](https://github.com/SWaiter/reflect.git)

rpc的实现在api模块中
```java
public class Main {
    public static void main(String[] args) {
        IProductService productService = (IProductService) com.yoozoo.api.Main.rpc(IProductService.class);
        Product product = productService.queryById(1025);
        System.out.println(product);
    }
}
```

### 商品服务（api模块）
1、首先是bean

```java
   public class Product implements Serializable{
       private long id;
       private String name;
       private double price;
       //省去set、get 、tostring 方法
       }

```
2、定义查询接口
```java
public interface IProductService {
    public Product queryById(long id);
}
```
3、接口实现

```java
public class ProductService implements IProductService{
    @Override
    public Product queryById(long id) {
        Product product = new Product();
        product.setId(id);
        product.setName("wangshan");
        product.setPrice(12211.2125);
        return product;
    }
}
```
4、rpc方法实现
```java
public static Object rpc(final Class iProductServiceClass) {
        return Proxy.newProxyInstance(iProductServiceClass.getClassLoader(), new Class[]{iProductServiceClass}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                Socket socket = new Socket("127.0.0.1", 19088);

                String apiClassName = iProductServiceClass.getName();
                String methodName = method.getName();
                Class[] parameterTypes = method.getParameterTypes();

                ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
                objectOutputStream.writeUTF(apiClassName);
                objectOutputStream.writeUTF(methodName);
                objectOutputStream.writeObject(parameterTypes);
                objectOutputStream.writeObject(args);
                objectOutputStream.flush();

                ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());
                Object o = objectInputStream.readObject();
                objectInputStream.close();
                objectOutputStream.close();

                socket.close();
                return o;
            }
        });
    }

```
5、rpc启动

```java
public static void main(String[] args) {
            try {
                ServerSocket serverSocket = new ServerSocket(19088);
                while (true) {
                    Socket socket = serverSocket.accept();
                    ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream());
    
                    String apiClassName = objectInputStream.readUTF();
                    String methodName = objectInputStream.readUTF();
                    Class[] parameterTypes = (Class[]) objectInputStream.readObject();
                    Object[] args4method = (Object[]) objectInputStream.readObject();
    
                    Class clazz = null;
    
                    if (apiClassName.equals(IProductService.class.getName())) {
                        clazz = ProductService.class;
                    }
                    Method method = clazz.getMethod(methodName, parameterTypes);
                    Object invoke = method.invoke(clazz.newInstance(), args4method);
    
                    ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream());
                    objectOutputStream.writeObject(invoke);
                    objectOutputStream.flush();
    
                    objectInputStream.close();
                    objectOutputStream.close();
                    socket.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
```

### 启动
1、首先启动api中的service中的Main.main方法  
2、然后启动service中的Main.main方法  
3、就可以获取服务对象
```bash
com.intellij.rt.execution.application.AppMain com.yoozoo.service.Main
Product{id=1025, name='wangshan', price=12211.2125}
Process finished with exit code 0
```

###项目地址

```bash
https://github.com/SWaiter/RPC.git
```

[我的git地址 https://github.com/SWaiter/RPC.git](https://github.com/SWaiter/RPC.git)


###总结

就这一个简单的rpc框架就完成了。有什么问题可以QQ联系交流。（787324413）
